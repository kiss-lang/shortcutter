(defMacroVar mainKissFile kissFile)
(loadFrom "kiss-firefox" "src/kiss_firefox/Util.kiss")
(loadFrom "kiss-firefox" "src/kiss_firefox/ContentUtil.kiss")

(import shortcutter.Main)
(import kiss.Stream)
(import js.html.Document)
(import js.html.Element)
(import js.html.Node)
(import js.Browser)

(var exampleScript
".item-tracker 
	.menu-items > table:nth-child(1) > tbody:nth-child(1) > tr
		td > div
	.pearls > div > div
	.triforce-and-pearls > tbody:nth-child(1) > tr:nth-child(1) > td:nth-child(2) > div:nth-child(1)
	.misc-items
		table:nth-child(1) > tbody:nth-child(1) > tr > td > div
.sea-sector
	Escape|0|.header-table > tbody:nth-child(1) > tr:nth-child(1) > td > div
	.detailed-locations-table > tbody:nth-child(1) > tr > td > div
.extra-locations")

(function :Int countTabLevel [:String line]
	(localVar &mut tabs 0)
	(while (= (line.charAt tabs) "\t")
		++tabs)
	tabs)

(function :Hierarchy parseHierarchy [:Stream script &opt :Int tabLevel :String selector]
	(unless tabLevel (set tabLevel 0))
	(unless selector (set selector ""))
	(let [:Hierarchy hierarchy (objectWith [children []] selector) 
			linesAtTabLevel (extractOpt (script.takeLinesAsStreamWhile ->line (>= (countTabLevel line) tabLevel)))]
		(until (linesAtTabLevel.isEmpty)
			(let [nextChild (extractOpt (linesAtTabLevel.takeLine))
					nextTabLevel (countTabLevel (extractOpt (linesAtTabLevel.peekLine) ""))]
				// Indent inward
				(if (> nextTabLevel tabLevel)
						(hierarchy.children.push (parseHierarchy linesAtTabLevel nextTabLevel nextChild))
					(hierarchy.children.push (object selector nextChild children [])))))
		hierarchy))

(var &mut currentHierarchy [])
(var &mut :Hierarchy rootHierarchy)
(var &mut :kiss.List<Element> currentElement [])
(var &mut :Map<String,Element> specialKeys (new Map))

(function querySelectorAll [:String selector &opt :Element element]
	(let [assignedKeys (.split (selector.ltrim) "|")
			selector (assignedKeys.pop)
			elements
				(if element
						(let [elementQuery (collect (element.querySelectorAll selector))]
							// Fall back to global if the localized selector finds nothing
							(or elementQuery (querySelectorAll selector)))
					(collect (Browser.window.document.querySelectorAll selector)))]
		(doFor [idx key] (enumerate assignedKeys)
			(dictSet specialKeys key (cast (nth elements idx))))
		elements))

(function :Array<Element> elementsOfLevel [:Hierarchy level &opt :Element element]
	(let [elements []]
		(doFor child level.children
		 	(doFor el (querySelectorAll child.selector element)
				(elements.push (cast el))))
		elements))

// On first load, elements may not have populated if the page is dynamically generating anything. So timed-out retrying might be needed
(var &mut retry true)

(function labelsElement []
	(ifLet [element (Browser.window.document.getElementById "SHORTCUTTER-LABELS")]
			element
		(let [element (Browser.window.document.createElement "div")]
			(set element.id "SHORTCUTTER-LABELS")
			(Browser.window.document.body.appendChild element)
			element)))

(var keys (.split "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" ""))

(function :Null selectHierarchy [:Hierarchy level :Bool on &opt :Element element]
	(set specialKeys (new Map))
	(localVar labels (labelsElement))
	(set labels.innerHTML "")
	(ifLet [elements (elementsOfLevel level element)]
		(if elements
				(doFor [idx element] (enumerate elements)
					// Highlight the element as selectable and show its key
					(when on
						(let [bounds (element.getBoundingClientRect)
						  		div (Browser.window.document.createElement "div")
								label (Browser.window.document.createElement "p")]
							(set label.innerHTML (nth keys idx))
							(set label.style.color "red")
							(set div.style.position "absolute")
							(set div.style.top "$(+ bounds.top Browser.window.scrollY)px")
							(set div.style.left "$(+ bounds.left Browser.window.scrollX)px")
							(set div.style.width "${bounds.width}px")
							(set div.style.height "${bounds.height}px")
							(set label.style.margin "0px")
							(set label.style.fontSize "2em")
							(set div.style.border "2px solid red")
							(div.appendChild label)
							(labels.appendChild div)))))))

(function :Null popHierarchy []
	(selectHierarchy (last currentHierarchy) false)
	(currentHierarchy.pop)
	(currentElement.pop)
	(unless currentHierarchy
		(set currentHierarchy [rootHierarchy])
		(set currentElement []))
	(selectHierarchy (last currentHierarchy) true))

(function :Null pushHierarchy [:Hierarchy level :Element element]
	(selectHierarchy (last currentHierarchy) false (last currentElement))
	(set retry true)
	(selectHierarchy level true element)
	(currentHierarchy.push level)
	(currentElement.push element))

(set rootHierarchy (parseHierarchy (Stream.fromString exampleScript)))
(set currentHierarchy [rootHierarchy])

(Browser.window.addEventListener "keydown"
	->:Null key
		(let [key key.key]
			(cond 
				((specialKeys.exists key)
					(.click (dictGet specialKeys key)))
				((keys.contains key)
					(print "keys contains")
					// Select corresponding element
					(let [elements (elementsOfLevel (last currentHierarchy) (last currentElement))
							elementSelected (nth elements (keys.indexOf key))
							&mut indexOfSelector 0]
						(doFor level .children (last currentHierarchy)
							(when (.contains (querySelectorAll level.selector (last currentElement)) elementSelected)
								(break))
							++indexOfSelector)
						(let [nextLevel (nth .children (last currentHierarchy) indexOfSelector)]
							(when nextLevel.children
								(pushHierarchy nextLevel elementSelected))
							// Click even when we're going deeper into the hierarchy -- which usually should no-op
							// and not be a problem
							(.click elementSelected)))))
			// Assign an element to Escape when you want it to also pop the hierarchy when triggered:
			(when (= key "Escape") (popHierarchy))))

(Browser.window.addEventListener "load"
	->_ (Browser.window.setInterval
		->_ (selectHierarchy (last currentHierarchy) true (last currentElement)) 300))