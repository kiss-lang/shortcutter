(defMacroVar mainKissFile kissFile)
(loadFrom "kiss-firefox" "src/kiss_firefox/Util.kiss")
(loadFrom "kiss-firefox" "src/kiss_firefox/ContentUtil.kiss")

(import shortcutter.Main)
(import kiss.Stream)
(import js.html.Document)
(import js.html.Element)
(import js.html.Node)
(import js.Browser)

(var exampleScript
".item-tracker 
	.menu-items > table:nth-child(1) > tbody:nth-child(1) > tr
		td > div
	.pearls > div > div
	.triforce-and-pearls > tbody:nth-child(1) > tr:nth-child(1) > td:nth-child(2) > div:nth-child(1)
	.misc-items
		table:nth-child(1) > tbody:nth-child(1) > tr > td > div
.chart-map-container
	.sea-sector
.extra-locations")

(function :Int countTabLevel [:String line]
	(localVar &mut tabs 0)
	(while (= (line.charAt tabs) "\t")
		++tabs)
	tabs)

(function :Hierarchy parseHierarchy [:Stream script &opt :Int tabLevel :String key :String selector]
	(unless tabLevel (set tabLevel 0))
	(unless key (set key ""))
	(unless selector (set selector ""))
	(let [:Hierarchy hierarchy (objectWith [children []] key selector) 
			linesAtTabLevel (extractOpt (script.takeLinesAsStreamWhile ->line (>= (countTabLevel line) tabLevel)))]
		(until (linesAtTabLevel.isEmpty)
			(let [nextChild (extractOpt (linesAtTabLevel.takeLine))
					nextTabLevel (countTabLevel (extractOpt (linesAtTabLevel.peekLine) ""))]
				// Indent inward
				(if (> nextTabLevel tabLevel)
						(hierarchy.children.push (parseHierarchy linesAtTabLevel nextTabLevel "" nextChild))
					(hierarchy.children.push (object key "" selector nextChild children [])))))
		hierarchy))

(var &mut currentHierarchy [])
(var &mut :Hierarchy rootHierarchy)
(var &mut :kiss.List<Element> currentElement [])

(function querySelectorAll [:String selector &opt :Element element]
	(if element
			(element.querySelectorAll selector)
		(Browser.window.document.querySelectorAll selector)))

(function :Array<Element> elementsOfLevel [:Hierarchy level &opt :Element element]
	(let [elements []]
		(doFor child level.children
		 	(doFor el (querySelectorAll child.selector element)
				(elements.push (cast el))))
		elements))

// On first load, elements may not have populated if the page is dynamically generating anything. So timed-out retrying might be needed
(var &mut retry true)

(function labelsElement []
	(ifLet [element (Browser.window.document.getElementById "SHORTCUTTER-LABELS")]
			element
		(let [element (Browser.window.document.createElement "div")]
			(set element.id "SHORTCUTTER-LABELS")
			(Browser.window.document.body.appendChild element)
			element)))

(var keys (.split "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" ""))

(function :Null selectHierarchy [:Hierarchy level :Bool on &opt :Element element]
	(localVar labels (labelsElement))
	(unless on (set labels.innerHTML ""))
	(ifLet [elements (elementsOfLevel level element)]
		(if elements
				(doFor [idx element] (enumerate elements)
					(set retry false)
					// Highlight the element as selectable and show its key
					(when on
						(let [bounds (element.getBoundingClientRect)
						  		div (Browser.window.document.createElement "div")
								label (Browser.window.document.createElement "p")]
							(set label.innerHTML (nth keys idx))
							(set label.style.color "red")
							(set div.style.position "absolute")
							(set div.style.top "$(+ bounds.top Browser.window.scrollY)px")
							(set div.style.left "$(+ bounds.left Browser.window.scrollX)px")
							(set div.style.width "${bounds.width}px")
							(set div.style.height "${bounds.height}px")
							(set label.style.margin "0px")
							(set label.style.fontSize "3em")
							(set div.style.border "2px solid red")
							(div.appendChild label)
							(labels.appendChild div)))
					)
			(when retry (Browser.window.setTimeout ->(selectHierarchy level on element) 500)))))

(function :Null popHierarchy []
	(selectHierarchy (last currentHierarchy) false)
	(currentHierarchy.pop)
	(currentElement.pop)
	(unless currentHierarchy
		(set currentHierarchy [rootHierarchy])
		(set currentElement []))
	(selectHierarchy (last currentHierarchy) true))

(function :Null pushHierarchy [:Hierarchy level :Element element]
	(selectHierarchy (last currentHierarchy) false (last currentElement))
	(selectHierarchy level true element)
	(currentHierarchy.push level)
	(currentElement.push element))

(set rootHierarchy (parseHierarchy (Stream.fromString exampleScript)))
(set currentHierarchy [rootHierarchy])

(Browser.window.addEventListener "keydown"
	->:Null key
		(case key.key
			("Escape"
				(popHierarchy))
			((when (keys.contains key) key)
				// Select corresponding element
				(let [elements (elementsOfLevel (last currentHierarchy) (last currentElement))
						elementSelected (nth elements (keys.indexOf key))
						&mut indexOfSelector 0]
					(doFor level .children (last currentHierarchy)
						(when (.contains (collect (querySelectorAll level.selector (last currentElement))) elementSelected)
							(break))
						++indexOfSelector)
					(let [nextLevel (nth .children (last currentHierarchy) indexOfSelector)]
					 	(if nextLevel.children
								(pushHierarchy nextLevel elementSelected)
							(.click elementSelected)))))
			(otherwise)))

(Browser.window.addEventListener "load"
	->_ (selectHierarchy rootHierarchy true))